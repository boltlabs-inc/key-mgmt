//! Public API for the DAMS local client library.

use crate::{
    keys::{KeyId, KeyInfo, KeyTag, UsePermission, UseRestriction, UserPolicySpecification},
    transaction::{TarId, TransactionApprovalRequest, TransactionSignature},
};

use thiserror::Error;

#[derive(Debug, Error)]
pub enum SessionError {}

#[derive(Debug)]
pub struct Password;

/// Deployment details for a session.
///
/// Sample fields: timeouts, key server IPs
#[derive(Debug)]
pub struct SessionConfig;

/// Communication session with a set of key servers.
/// A session can be ended manually, or it might time out and require
/// re-authentication (that is, a new [`Session`])
#[allow(unused)]
pub struct Session {
    config: SessionConfig,
}

#[allow(unused)]
impl Session {
    /// Open a new session for a registered user.
    pub fn open(password: Password, config: &SessionConfig) -> Result<Self, SessionError> {
        todo!()
    }

    /// Register a new user who has not yet interacted with the service.
    pub fn register(password: Password, config: &SessionConfig) -> Result<Self, SessionError> {
        todo!()
    }

    /// Close a session.
    pub fn close(self) -> Result<(), SessionError> {
        todo!()
    }
}

#[derive(Debug, Error)]
#[allow(unused)]
pub enum Error {
    #[error("Session failed: {0:?}")]
    SessionError(#[from] SessionError),

    #[error("Expected a delegated key, but got a self-custodial or passive key")]
    ExpectedDelegatedKey,

    #[error("The request was rejected")]
    TransactionApprovalRequestFailed,
}

#[allow(unused)]
pub fn create_digital_asset_key(
    session: Session,
    key_tag: Option<KeyTag>,
    //blockchain:
    permission: impl UsePermission,
    restriction: impl UseRestriction,
) -> Result<(), Error> {
    todo!()
}

/// Set a user key policy for a delegated key.
///
/// Errors: If the key with given ID is not delegated, returns
/// [`Error::ExpectedDelegatedKey`].
#[allow(unused)]
pub fn set_user_key_policy(
    session: Session,
    key_id: KeyId,
    user_policy: UserPolicySpecification,
) -> Result<(), Error> {
    todo!()
}

/// Request approval for a transaction.
#[allow(unused)]
pub fn transaction_approval_request(
    session: Session,
    transaction_approval_request: TransactionApprovalRequest,
) -> Result<TransactionSignature, Error> {
    todo!()
}

/// Retrieve the signature generated by the transaction approval request with
/// the given ID.
#[allow(unused)]
pub fn transaction_signature_export(
    session: Session,
    tar_id: TarId,
) -> Result<TransactionSignature, Error> {
    todo!()
}

/// Retrieve the public key info for all keys associated with the user (as
/// defined by the open `session`).
#[allow(unused)]
pub fn retrieve_keys(session: Session) -> Result<KeyInfo, Error> {
    todo!()
}

/// Retrieve the public key info for the specified key associated with the user
/// (as defined by the open `session`).
#[allow(unused)]
pub fn retrieve_public_key(session: Session, key_id: &KeyId) -> Result<KeyInfo, Error> {
    todo!()
}

/// Retrieve the audit log for the user (as defined by the open `session`);
/// optionally, filter for logs associated with the specified [`KeyId`].
/// The audit log includes actions, date, approvals, context about the request.
///
/// Future updates: add an optional date range, update return type.
#[allow(unused)]
pub fn retrieve_audit_log(session: Session, key_id: Option<&KeyId>) -> Result<String, Error> {
    todo!()
}
