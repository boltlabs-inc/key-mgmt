use metered::measure;
use rand::{CryptoRng, RngCore};
use std::{fmt::Debug, sync::Arc};
use tokio::sync::{mpsc::Sender, Mutex};
use tokio_stream::StreamExt;
use tonic::{Response, Streaming};

use lock_keeper::{
    crypto::{Encrypted, OpaqueSessionKey},
    rpc::Message,
    types::operations::ConvertMessage,
    LockKeeperError,
};

use crate::client::ChannelMetrics;

/// Client-side implementation of a two-way channel between the client and a
/// server used to communicate `Message` objects.
///
/// This bidirectional `Channel` is implemented under the hood as two
/// unidirectional channels. It can only be used with streaming messages
/// generated by `tonic`.
///
/// These are tokio MPSC channels, but `tonic` is able to use them to send
/// messages via the network between the server and client.
#[derive(Debug)]
pub struct Channel<AUTH> {
    /// Sending end of an unidirectional channel. Allows us to send messages to
    /// the server. This client created both ends of this channel and sent
    /// the receiver to the server via a gRPC call.
    sender: Sender<Message>,
    /// A receiver end of an unidirectional channel. Allows us to receive
    /// messages from the server. When we made a gRPC call, the server sent this
    /// receiving end. The server can send messages to it and we will
    /// receive them.
    receiver: Streaming<Message>,
    auth: AUTH,
    pub metrics: Arc<ChannelMetrics>,
}

/// Passed to channel type as the `AUTH` generic parameter.
/// It is used for channels that handle authenticated operations.
/// This type ensures that messages moving across a channel are encrypted.
pub struct Authenticated<RNG: CryptoRng + RngCore> {
    pub session_key: OpaqueSessionKey,
    pub rng: Arc<Mutex<RNG>>,
}

/// Passed to channel type as the `AUTH` generic parameter.
/// It is used for channels that handle unauthenticated operations.
/// This type does nothing to modify messages passed across a channel.
pub struct Unauthenticated;

impl Channel<Unauthenticated> {
    pub fn new(
        sender: Sender<Message>,
        response: Response<Streaming<Message>>,
        metrics: Arc<ChannelMetrics>,
    ) -> Result<Self, LockKeeperError> {
        Ok(Self {
            sender,
            receiver: response.into_inner(),
            auth: Unauthenticated,
            metrics,
        })
    }

    pub fn into_authenticated<RNG: CryptoRng + RngCore>(
        self,
        session_key: OpaqueSessionKey,
        rng: Arc<Mutex<RNG>>,
    ) -> Channel<Authenticated<RNG>> {
        Channel {
            sender: self.sender,
            receiver: self.receiver,
            auth: Authenticated { session_key, rng },
            metrics: self.metrics,
        }
    }

    /// Receive the next message on the channel and convert it to the type `R`.
    pub async fn receive<R: ConvertMessage>(&mut self) -> Result<R, LockKeeperError> {
        match measure!(&self.metrics.receive_message, self.receiver.next().await) {
            Some(message) => {
                let message = message?;
                let result = measure!(&self.metrics.receive_from_message, {
                    R::from_message(message).map_err(|_| LockKeeperError::InvalidMessage)?
                });
                Ok(result)
            }
            None => Err(LockKeeperError::NoMessageReceived),
        }
    }

    /// Send a message across the channel. This function accepts any type that
    /// can be converted to a `Message`.
    pub async fn send(&mut self, message: impl ConvertMessage) -> Result<(), LockKeeperError> {
        let payload = measure!(&self.metrics.send_to_message, message.to_message()?);
        Ok(measure!(
            &self.metrics.send_message,
            self.sender.send(payload).await?
        ))
    }
}

impl<RNG: CryptoRng + RngCore> Channel<Authenticated<RNG>> {
    /// Receive the next message on the channel and convert it to the type `R`.
    pub async fn receive<R: ConvertMessage>(&mut self) -> Result<R, LockKeeperError> {
        match measure!(&self.metrics.receive_message, self.receiver.next().await) {
            Some(message) => {
                let message = message?;
                let encrypted_message: Encrypted<Message> = measure!(
                    &self.metrics.receive_into_encrypted,
                    Encrypted::<Message>::try_from_message(message)?
                );
                let message = measure!(
                    &self.metrics.receive_decrypt,
                    encrypted_message.decrypt_message(&self.auth.session_key)?
                );
                let result = measure!(
                    &self.metrics.receive_from_message,
                    R::from_message(message).map_err(|_| LockKeeperError::InvalidMessage)?
                );
                Ok(result)
            }
            None => Err(LockKeeperError::NoMessageReceived),
        }
    }

    /// Send a message across the channel. This function accepts any type that
    /// can be converted to a `Message`.
    pub async fn send(&mut self, message: impl ConvertMessage) -> Result<(), LockKeeperError> {
        let message = measure!(&self.metrics.send_to_message, message.to_message()?);

        let encrypted = measure!(&self.metrics.send_encrypt, {
            let mut rng = self.auth.rng.lock().await;
            self.auth
                .session_key
                .encrypt(&mut *rng, message)
                .map_err(LockKeeperError::Crypto)?
        });
        let encrypted_message = measure!(
            &self.metrics.send_try_into_message,
            encrypted.try_into_message()?
        );

        Ok(measure!(
            &self.metrics.send_message,
            self.sender.send(encrypted_message).await?
        ))
    }
}
