use rand::{CryptoRng, RngCore};
use std::{fmt::Debug, sync::Arc};
use tokio::sync::{mpsc::Sender, Mutex};
use tokio_stream::StreamExt;
use tonic::{Response, Streaming};

use lock_keeper::{
    crypto::{Encrypted, OpaqueSessionKey},
    rpc::Message,
    types::operations::ConvertMessage,
    LockKeeperError,
};

/// A two-way channel between a client and server used to communicate with
/// `Message` objects. `Channel` uses `tonic` types to receive messages. It can
/// only be used with streaming messages generated by `tonic`.
#[derive(Debug)]
pub struct Channel<AUTH> {
    sender: Sender<Message>,
    receiver: Streaming<Message>,
    auth: AUTH,
}

/// Passed to channel type as the `AUTH` generic parameter.
/// It is used for channels that handle authenticated operations.
/// This type ensures that messages moving across a channel are encrypted.
pub struct Authenticated<RNG: CryptoRng + RngCore> {
    pub session_key: OpaqueSessionKey,
    pub rng: Arc<Mutex<RNG>>,
}

/// Passed to channel type as the `AUTH` generic parameter.
/// It is used for channels that handle unauthenticated operations.
/// This type does nothing to modify messages passed across a channel.
pub struct Unauthenticated;

impl Channel<Unauthenticated> {
    pub fn new(
        sender: Sender<Message>,
        response: Response<Streaming<Message>>,
    ) -> Result<Self, LockKeeperError> {
        Ok(Self {
            sender,
            receiver: response.into_inner(),
            auth: Unauthenticated,
        })
    }

    pub fn into_authenticated<RNG: CryptoRng + RngCore>(
        self,
        session_key: OpaqueSessionKey,
        rng: Arc<Mutex<RNG>>,
    ) -> Channel<Authenticated<RNG>> {
        Channel {
            sender: self.sender,
            receiver: self.receiver,
            auth: Authenticated { session_key, rng },
        }
    }

    /// Receive the next message on the channel and convert it to the type `R`.
    pub async fn receive<R: ConvertMessage>(&mut self) -> Result<R, LockKeeperError> {
        match self.receiver.next().await {
            Some(message) => {
                let message = message?;
                let result =
                    R::from_message(message).map_err(|_| LockKeeperError::InvalidMessage)?;
                Ok(result)
            }
            None => Err(LockKeeperError::NoMessageReceived),
        }
    }

    /// Send a message across the channel. This function accepts any type that
    /// can be converted to a `Message`.
    pub async fn send(&mut self, message: impl ConvertMessage) -> Result<(), LockKeeperError> {
        let payload = message.to_message()?;
        Ok(self.sender.send(payload).await?)
    }
}

impl<RNG: CryptoRng + RngCore> Channel<Authenticated<RNG>> {
    /// Receive the next message on the channel and convert it to the type `R`.
    pub async fn receive<R: ConvertMessage>(&mut self) -> Result<R, LockKeeperError> {
        match self.receiver.next().await {
            Some(message) => {
                let message = message?;
                let encrypted_message: Encrypted<Message> =
                    Encrypted::<Message>::try_from_message(message)?;
                let message = encrypted_message.decrypt_message(&self.auth.session_key)?;
                let result =
                    R::from_message(message).map_err(|_| LockKeeperError::InvalidMessage)?;
                Ok(result)
            }
            None => Err(LockKeeperError::NoMessageReceived),
        }
    }

    /// Send a message across the channel. This function accepts any type that
    /// can be converted to a `Message`.
    pub async fn send(&mut self, message: impl ConvertMessage) -> Result<(), LockKeeperError> {
        let message = message.to_message()?;

        let encrypted_message = {
            let mut rng = self.auth.rng.lock().await;
            self.auth
                .session_key
                .encrypt(&mut *rng, message)
                .map_err(LockKeeperError::Crypto)?
        }
        .try_into_message()?;

        Ok(self.sender.send(encrypted_message).await?)
    }
}
