use bytes::BytesMut;
use rand::{CryptoRng, RngCore};
use serde::{Deserialize, Serialize};

use crate::{keys::KeyId, user::UserId};

/// An export key is secure key material produced as client output from OPAQUE.
///
/// This uses standardized naming, but is _not_ directly used as an encryption
/// key in this system. Instead, it is used to derive a `MasterKey`.
///
/// Implementation note: this will be a wrapper around `opaque_ke`'s `export_key`
/// field in the
/// [ClientRegistrationFinishResult](opaque_ke::ClientRegistrationFinishResult)
/// and corresponding registration result.
#[allow(unused)]
#[derive(Debug)]
pub struct ExportKey;

impl ExportKey {
    /// Derive a [`MasterKey`] from the export key.
    pub fn derive_master_key(&self) -> MasterKey {
        todo!()
    }
}

/// The master key is a default-length symmetric key for (TODO #107: encryption
/// scheme). It is used by the user to securely encrypt their [`StorageKey`].
#[allow(unused)]
#[derive(Debug)]
pub struct MasterKey;

#[allow(unused)]
impl MasterKey {
    /// Encrypt the given [`StorageKey`] under an AEAD scheme (TODO #107:
    /// describe).
    ///
    /// TODO #113: Add encrypted storage key return type.
    pub fn encrypt_storage_key(self, storage_key: StorageKey) {
        todo!()
    }
}

/// A storage key is used to encrypt stored data. It is derived by and only
/// known to a client.
///
/// A storage key is a default-length symmetric key for (TODO #107: encryption
/// scheme).
#[allow(unused)]
#[derive(Debug)]
pub struct StorageKey;

#[allow(unused)]
impl StorageKey {
    /// Generate a new 32-byte [`StorageKey`].
    pub fn generate() -> Self {
        todo!()
    }

    /// Encrypt the given [`Secret`] under an AEAD scheme (TODO #107:
    /// describe).
    ///
    /// TODO #113: Add encrypted storage key return type.
    pub fn encrypt_data(self, secret: &Secret) {
        todo!()
    }
}

/// An arbitrary secret.
///
/// This is generated by and known only to the client.
#[derive(Debug, Deserialize, Serialize)]
pub struct Secret {
    material: BytesMut,
    len: u32,
    context: Context,
}

#[allow(unused)]
impl Secret {
    /// Generate a new secret of length `len`.
    pub fn generate(
        rng: impl CryptoRng + RngCore,
        len: u32,
        user_id: UserId,
        key_id: KeyId,
    ) -> Self {
        todo!()
    }
}

#[cfg(test)]
impl Default for Secret {
    fn default() -> Self {
        Secret {
            material: BytesMut::new(),
            len: 0,
            context: Context::Secret(UserId::default(), KeyId),
        }
    }
}

/// Context and application specific information used in various cryptographic
/// protocols. This enum lists the specific contexts that arise throughout the
/// system.
///
/// Context is used in key derivation and authenticated encryption with
/// associated data.
#[allow(unused)]
#[derive(Debug, Serialize, Deserialize)]
enum Context {
    /// OPAQUE-derived Lock Keeper master key.
    MasterKey,
    /// Arbitrarily generated Lock Keeper storage key.
    StorageKey,
    /// A secret stored by the specified user under the given [`KeyId`].
    Secret(UserId, KeyId),
}

#[cfg(test)]
mod test {
    use super::*;

    #[test]
    #[should_panic(expected = "not yet implemented")]
    fn derive_master_key_not_implemented() {
        let _master_key = ExportKey.derive_master_key();
    }

    #[test]
    #[should_panic(expected = "not yet implemented")]
    fn encrypt_storage_key_not_implemented() {
        MasterKey.encrypt_storage_key(StorageKey);
    }

    #[test]
    #[should_panic(expected = "not yet implemented")]
    fn storage_key_generation_not_implemented() {
        let _storage_key = StorageKey::generate();
    }

    #[test]
    #[should_panic(expected = "not yet implemented")]
    fn data_encryption_not_implemented() {
        let secret = Secret::default();
        StorageKey.encrypt_data(&secret)
    }

    #[test]
    #[should_panic(expected = "not yet implemented")]
    fn secret_generation_not_implemented() {
        let thread_rng = rand::thread_rng();
        let user_id = UserId::default();
        let _secret = Secret::generate(thread_rng, 32, user_id, KeyId);
    }
}
