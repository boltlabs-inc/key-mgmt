use rand::{CryptoRng, RngCore};
use std::{fmt::Debug, sync::Arc};
use tokio::sync::{
    mpsc::{self, Receiver, Sender},
    Mutex,
};
use tokio_stream::StreamExt;
use tonic::{Request, Status, Streaming};

use crate::{
    constants::METADATA,
    crypto::{Encrypted, OpaqueSessionKey},
    rpc::Message,
    types::{
        database::user::UserId,
        operations::{ConvertMessage, RequestMetadata},
    },
    LockKeeperError,
};

use super::{Authenticated, Unauthenticated, BUFFER_SIZE};

/// A two-way channel between a client and server used to communicate with
/// `Message` objects. `Channel` uses `tonic` types to receive messages. It can
/// only be used with streaming messages generated by `tonic`.
///
/// The implementations are slightly different between the client and server due
/// to the types required by the code auto-generated by `tonic`.
#[derive(Debug)]
pub struct ServerChannel<AUTH> {
    sender: Sender<Result<Message, Status>>,
    receiver: Streaming<Message>,
    metadata: RequestMetadata,
    auth: AUTH,
}

impl<AUTH> ServerChannel<AUTH> {
    /// Returns the metadata associated with this channel.
    pub fn metadata(&self) -> &RequestMetadata {
        &self.metadata
    }

    pub fn set_user_id(&mut self, user_id: UserId) {
        self.metadata.set_user_id(user_id)
    }

    /// Consumes the channel and returns the metadata.
    /// Use this when you're finished with the channel but need to return the
    /// metadata.
    pub fn into_metadata(self) -> RequestMetadata {
        self.metadata
    }

    /// Send an error message across the channel.
    pub async fn send_error(&mut self, status: impl Into<Status>) -> Result<(), LockKeeperError> {
        let payload = Err(status.into());
        Ok(self.sender.send(payload).await?)
    }

    pub async fn closed(&mut self) {
        self.sender.closed().await;
    }
}

impl ServerChannel<Unauthenticated> {
    pub fn new(
        request: Request<Streaming<Message>>,
    ) -> Result<(Self, Receiver<Result<Message, Status>>), LockKeeperError> {
        let (sender, remote_receiver) = mpsc::channel(BUFFER_SIZE);

        let metadata = request
            .metadata()
            .get(METADATA)
            .ok_or(LockKeeperError::MetadataNotFound)?
            .try_into()?;

        Ok((
            Self {
                sender,
                receiver: request.into_inner(),
                metadata,
                auth: Unauthenticated,
            },
            remote_receiver,
        ))
    }

    pub fn into_authenticated<RNG: CryptoRng + RngCore>(
        self,
        session_key: OpaqueSessionKey,
        rng: Arc<Mutex<RNG>>,
    ) -> ServerChannel<Authenticated<RNG>> {
        ServerChannel {
            sender: self.sender,
            receiver: self.receiver,
            metadata: self.metadata,
            auth: Authenticated { session_key, rng },
        }
    }

    /// Receive the next message on the channel and convert it to the type `R`.
    pub async fn receive<R: ConvertMessage>(&mut self) -> Result<R, LockKeeperError> {
        match self.receiver.next().await {
            Some(message) => {
                let message = message?;
                let result =
                    R::from_message(message).map_err(|_| LockKeeperError::InvalidMessage)?;
                Ok(result)
            }
            None => Err(LockKeeperError::NoMessageReceived),
        }
    }

    /// Send a message across the channel. This function accepts any type that
    /// can be converted to a `Message`.
    pub async fn send(&mut self, message: impl ConvertMessage) -> Result<(), LockKeeperError> {
        let payload = Ok(message.to_message()?);
        Ok(self.sender.send(payload).await?)
    }
}

impl<RNG: CryptoRng + RngCore> ServerChannel<Authenticated<RNG>> {
    /// Receive the next message on the channel and convert it to the type `R`.
    pub async fn receive<R: ConvertMessage>(&mut self) -> Result<R, LockKeeperError> {
        match self.receiver.next().await {
            Some(message) => {
                let message = message?;
                let encrypted_message: Encrypted<Message> =
                    Encrypted::<Message>::try_from_message(message)?;
                let message = encrypted_message.decrypt_message(&self.auth.session_key)?;
                let result =
                    R::from_message(message).map_err(|_| LockKeeperError::InvalidMessage)?;
                Ok(result)
            }
            None => Err(LockKeeperError::NoMessageReceived),
        }
    }

    /// Send a message across the channel. This function accepts any type that
    /// can be converted to a `Message`.
    pub async fn send(&mut self, message: impl ConvertMessage) -> Result<(), LockKeeperError> {
        let message = message.to_message()?;

        let encrypted_message = {
            let mut rng = self.auth.rng.lock().await;
            self.auth
                .session_key
                .encrypt(&mut *rng, message)
                .map_err(LockKeeperError::Crypto)?
        }
        .try_into_message()?;

        let payload = Ok(encrypted_message);

        Ok(self.sender.send(payload).await?)
    }
}
