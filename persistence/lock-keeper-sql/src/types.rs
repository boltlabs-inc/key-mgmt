use crate::error::PostgresError;
use lock_keeper::{
    crypto::KeyId,
    types::{
        audit_event::{AuditEvent, EventStatus},
        database::{
            secrets::StoredSecret,
            user::{Account, AccountName, UserId},
        },
        operations::ClientAction,
    },
};
use std::str::FromStr;
use time::OffsetDateTime;
use uuid::Uuid;

/// Mapping of our [Account] type as it looks in the table. sqlx can use this to
/// map selected rows to this rust type.
pub(crate) struct AccountDB {
    // We will get rid of this next PR when the ID is used.
    #[allow(unused)]
    pub(crate) account_id: i64,
    pub(crate) user_id: Vec<u8>,
    pub(crate) account_name: String,
    pub(crate) storage_key: Option<Vec<u8>>,
    pub(crate) server_registration: Vec<u8>,
}

/// Mapping of our [StoredSecret] type as it looks in the table. sqlx can use
/// this to map selected rows to this rust type.
pub(crate) struct SecretDB {
    pub(crate) key_id: Vec<u8>,
    pub(crate) user_id: Vec<u8>,
    pub(crate) secret_type: String,
    pub(crate) secret: Vec<u8>,
    pub(crate) retrieved: bool,
}

/// Mapping of our [AuditEvent] type as it looks in the table. sqlx can use this
/// to map selected rows to this rust type.
///
/// This type implement `sqlx::FromRow` via a derive macro. This is needed as
/// this type is used in a dynamically-generated query.
#[derive(sqlx::FromRow)]
pub(crate) struct AuditEventDB {
    /// Unique ID auto-generated by database.
    pub(crate) audit_event_id: i64,
    pub(crate) account_name: String,
    pub(crate) key_id: Option<Vec<u8>>,
    pub(crate) request_id: Uuid,
    pub(crate) action: String,
    pub(crate) event_status: String,
    pub(crate) timestamp: OffsetDateTime,
}

impl TryFrom<SecretDB> for StoredSecret {
    type Error = PostgresError;

    fn try_from(secret: SecretDB) -> Result<Self, Self::Error> {
        let key_id = secret.key_id.as_slice().try_into()?;
        let user_id = secret.user_id.as_slice().try_into()?;
        Ok(StoredSecret {
            key_id,
            user_id,
            secret_type: secret.secret_type,
            bytes: secret.secret,
            retrieved: secret.retrieved,
        })
    }
}

impl TryFrom<AccountDB> for Account {
    type Error = PostgresError;

    fn try_from(user: AccountDB) -> Result<Self, Self::Error> {
        let storage_key = user
            .storage_key
            .map(|storage_key| bincode::deserialize(&storage_key))
            .transpose()?;

        Ok(Account {
            user_id: UserId::try_from(user.user_id.as_slice())?,
            account_name: AccountName::from(user.account_name.as_str()),
            storage_key,
            server_registration: bincode::deserialize(&user.server_registration)?,
        })
    }
}

impl From<StoredSecret> for SecretDB {
    fn from(secret: StoredSecret) -> Self {
        SecretDB {
            key_id: secret.key_id.as_bytes().to_vec(),
            user_id: secret.user_id.as_ref().to_vec(),
            secret_type: secret.secret_type,
            secret: secret.bytes,
            retrieved: secret.retrieved,
        }
    }
}

impl TryFrom<AuditEventDB> for AuditEvent {
    type Error = PostgresError;

    fn try_from(event: AuditEventDB) -> Result<Self, Self::Error> {
        let action = ClientAction::from_str(&event.action).map_err(|e| {
            PostgresError::AuditEventConversion(format!("ClientAction conversion failed {}", e))
        })?;

        let secret_id: Option<KeyId> = match event.key_id {
            None => None,
            Some(key_id) => {
                let key_id = TryFrom::try_from(key_id.as_slice()).map_err(|e| {
                    PostgresError::AuditEventConversion(format!("KeyID conversion failed: {}", e))
                })?;
                Some(key_id)
            }
        };
        let status = EventStatus::from_str(&event.event_status).map_err(|e| {
            PostgresError::AuditEventConversion(format!("EventStatus conversion failed {}", e))
        })?;

        let event = AuditEvent {
            audit_event_id: event.audit_event_id,
            request_id: event.request_id,
            account_name: AccountName::from(event.account_name.as_str()),
            key_id: secret_id,
            timestamp: event.timestamp,
            action,
            status,
        };

        Ok(event)
    }
}
